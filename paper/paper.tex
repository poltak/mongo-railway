\documentclass[a4paper,11pt]{article}

\usepackage[paper=a4paper,left=30mm,width=150mm,top=25mm,bottom=25mm]{geometry}
\usepackage[hidelinks]{hyperref}    % All references will auto hyperlink
\usepackage[font={small}]{caption}  % Make figure captions smaller
\usepackage{graphicx}               % For the displaying of images in floats
\usepackage{mathtools}              % For more advanced math usage
\usepackage{poltakmacros}           % Personal macro package (https://gist.github.com/poltak/6ed59e8f30c9c399143f)



\begin{document}

\include{titlepage}                 % Pull in title page

\newpage
\pagenumbering{roman}
\tableofcontents
\newpage

\pagenumbering{arabic}


\section{Introduction} % (fold)
\label{sec:introduction}

While relational database management systems (RDBMS) have been somewhat of a ``go-to'' solution for for a number of years
for general data storage and management problems that many application developers face, we have noted a recent rise
in the use of non-relational data management tools~\cite{padhy2011rdbms}. Most of these tools have traditionally fallen into the domain of
big data analytics, with platforms such as the Hadoop ecosystem~\footnote{https://hadoop.apache.org/} being notably popular.
However, outside of the domain of big data, looking more at general purpose data storage and management, what are now
commonly referred to as ``NoSQL'' solutions are proving to be a popular solution.

NoSQL databases refer to those databases that are not built on top of the relational algebraic concepts, as laid out by
Codd in 1970~\cite{codd1970relational}, unlike the more commonly used RDBMS technologies, such as
MySQL~\footnote{https://www.mysql.com/}. Being free of the strictness the relational model enforces on its data allows
NoSQL databases to focus less on the overall structure of data, and more on factors such as scalability and
performance~\cite{leavitt2010will}.

While the relational model is a good fit for many data problems, its strictness in terms of flexibility of managing data
eventually led to the introduction of the NoSQL model. The following characteristics can be given as a starting point
for NoSQL databases in comparison to relational databases~\cite{indrawan2012database}:

\begin{itemize}
  \item \textbf{Unstructured data support:} While the relational model would often force data to be stored in tabular
  formats, the NoSQL model does not force any kind of data schema.
  \item \textbf{Designed with distributed processing and horizontal scalability in mind:} Given the commoditisation of
  computer hardware in the last decade, support for horizontal scaling and processing among clusters is an important
  factor for adoption.
  \item \textbf{Less strict adherence to ACID principles:} While the relational model attempted to very much adhere to
  the transactional principles of data atomicity, consistency, isolation, and durability (ACID), this very much impacts
  performance in terms of distributed computing. Relaxing the strictness of adherence to these principles, allow many
  NoSQL databases to make the trade-off for higher performance.
\end{itemize}

Of course, these differences between the NoSQL model and relational model vary between each individual database
technology's design, and trade-offs are often made depending on the goals and aims for that given database.

In this paper, we will look at the use of MongoDB~\footnote{https://www.mongodb.org/}, a popular NoSQL database solution,
as a solution for a case study based upon a railway data problem using data from Monash University's Institute of Railway
Technology (IRT). An overview of the case study in question will be given in~\sectref{sec:case_study_overview}. A small
overview of the MongoDB database will be given in~\sectref{sec:mongo_overview}. Implementation and
evaluation details will be given in~\sectref{sec:implementation} and~\sectref{sec:evaluation_and_discussion}, respectively,
before concluding in~\sectref{sec:conclusion}.

% section introduction (end)

\newpage

\section{Case Study Overview} % (fold)
\label{sec:case_study_overview}

The case study that is being looked at involves a project that has been worked at at the Monash University Institute of
Railway technology (IRT). The project involves trains the operate in the Pilbara region of Western Australia, taking
ore and minerals from loading points at mines to a specified unloading port. The data that is being dealt with comes from
numerous categories of sensors being placed on certain specialised train cars to record data monitoring track and train
car conditions~\cite{darby2003development,darby2005track}.

Data currently gets unloaded at sent back in large batches to remote servers once the car completes a trip and pulls back
into port~\cite{thomas2012taking}. The project currently makes use of a RDBMS solution to manage data storage, however
this solution is faced with many problems that currently require painful work-arounds. The most obvious of which involves
unreliable data being received from sensors. For example, in the case of a damaged or failed sensor, reliable data cannot
be guaranteed to be returned from such a sensor. Hence, data received by the remote server is often inconsistently
structured, and thus the data has to go through a series of preprocessing work arounds to fit in within the strict
schema that the RDBMS expects. As the only guaranteed consistency in the data that gets received is the timestamp and
geocoordinates, the strictly structured relational model is not an appropriate solution.

The Monash IRT team are currently investigating further solutions in the NoSQL big data space, where they intend to
replace the current system with an appropriately tested solution. While the scope of that project is much larger than
what will be covered in this paper, we will look at the differences in what is possible when attempting to use a NoSQL
database for the data storage and management.

For this paper, we will be looking at the possibility of using MongoDB, a popular NoSQL database that does away with
the concept of the schemas and tables so commonly found in databases following the relational model. This is done with
the expectation of better handling of the given inconsistent data.

% section case_study_overview (end)

\newpage

\section{MongoDB Overview} % (fold)
\label{sec:mongo_overview}

\textit{Note that most of the information relevant to MongoDB in this section is sourced from the official MongoDB
manual.}~\cite{Mongo_man}

\subsection{Data storage} % (fold)
\label{sub:data_storage}

MongoDB can be described as a documented-oriented NoSQL database, which does not rely on schemas or tables to structure
its data~\cite{parker2013comparing}. Data within Mongo is stored using JSON-like structured documents, called
BSON~\cite{bsons6:online}, which allows for strongly typed data fields and binary data. BSON documents are then stored
within ``collections'' which reside in a given ``database''~\cite{parker2013comparing}. To relate back to the relational
model, these concepts within Mongo can be compared as shown in~\tabref{tab:mongo_to_relational}.

\begin{table}[h]
\centering
\caption{MongoDB conceptual structures as they relate to the relational model concepts.}
\label{tab:mongo_to_relational}
\begin{tabular}{ | l | l | }

\hline
\textbf{MongoDB}  & \textbf{Relational Model} \\ \hline
Database          & Database                  \\ \hline
Collection        & Table                     \\ \hline
BSON Document     & Record/Row/Tuple          \\ \hline
BSON Key          & Column/Field              \\ \hline
BSON Value        & Value                     \\ \hline

\end{tabular}
\end{table}

While these concepts within Mongo can be related back to concepts within the relational model for ease of understanding,
they are not exactly the same. For example, a table in the relational model is structured in such a way that all records
within that table must adhere to. Conversely, in a Mongo collection, several differently structured BSON documents may
coexist freely. BSON documents generally follow some sort of predefined structure for that collection, to maintain
data structure sanity, for the user's sake, however none of this is enforced.

This sort of freedom in terms of structure allows for similarly structured documents in database collections, where
differences may only be found in that certain documents may miss keys that are present in other documents. This is
highly rational in the way that, depending on the use-case, data may not be present for certain fields all the time.
Thus instead of placing null or default values for missing data, Mongo allows the user to just leave them out of the
relevant document. Note that document structure in Mongo is also dynamic in the way that it can be changed at any time;
BSON keys and values may be added or removed from existing documents at any time.

% subsection data_storage (end)

\subsection{Data interaction} % (fold)
\label{sub:data_interaction}

MongoDB allows a lot of the similar type functionality in queries and data manipulation that is also expected in
relational databases. Generally interactions with data are performed through JavaScript functions on collections, or cursors
(subsets of documents within a collection), allowing general querying operations through use of the \texttt{find()} function,
and standard CRUD operations through the \texttt{create()}, \texttt{update()}, and \texttt{remove()} functions.

MongoDB officially provides support for many drivers allowing interaction with Mongo databases in different programming
languages, including JavaScript, Python, and Java. As well as providing drivers, MongoDB also provides a default shell,
called the \textit{mongo shell}, which allows general JavaScript code to be written to interact with the standard MongoDB
API and perform ad-hoc queries. No official graphical user interface exists to interact with MongoDB, however there
are numerous third party clients, which essentially wrap around mongo shell.

MongoDB also supports more advanced data manipulation operations through use of aggregation functions. Generally, aggregation
functions are user defined operations to perform on documents in collections to return results. These include general
aggregate operation models, such as MapReduce, and often involve grouping documents by given keys and various queries
to limit the amount of documents to process.


% subsection data_interaction (end)

\subsection{Further database features} % (fold)
\label{sub:further_database_features}

\subsubsection{Lack of joins} % (fold)
\label{ssub:joins}

MongoDB, like many other NoSQL databases, does not support the joins of multiple tables or, in MongoDB's case, documents,
as is common in relational databases.
Instead, MongoDB allows two main ways of relating different documents to each other. These are via referencing and
nested documents. Nested documents are the main recommended way of join multiple documents, unless the documents have
many-to-many relationships. To allow nested documents, a BSON value can store a whole other document, or arrays of documents.
Example use-cases of where nested documents are appropriate include documents that have natural ``child'' documents that
only it will ever need to reference. For example, a blog post document may have many nested comment documents as the
comments are specific to a given blog post. For documents where many things may refer to it, it is recommended to use
references via BSON values containing other document IDs.

% subsubsection joins (end)

\subsubsection{Indexing} % (fold)
\label{ssub:indexing}

Indexing in MongoDB is supported in a similar ways that are present in relational databases. Mongo builds a B-Tree data
structure on a particular collection's key, allowing all documents within that collection with that key to be accessed
in $O(log n)$ time, as opposed to $O(n)$ time if unindexed. MongoDB also supports numerous types of indexes, such as
single-key, multi-key, geospatial, and hashed indexes.

% subsubsection indexing (end)

\subsubsection{Replication} % (fold)
\label{ssub:replication}

MongoDB allows replication and management of multiple copies of the same data for the purpose of increasing data
redundancy and availability. Replication in Mongo is managed using a primary instance of data, with secondaries replicating
the data in the primary using operation logs (\textit{oplogs}) to mimic any operations on data that were performed in the
primary. Replicas have fault tolerance in the way that if the primary fails, an election is started to promote any of the
secondaries to become a primary. In general, a client will only interact with a primary, however operations can also be
specified to be performed on specific secondaries. However, as replication data is asynchronously managed, any reads
performed specifically on secondaries may not give up-to-date data.

% subsubsection replication (end)

\subsubsection{Sharding} % (fold)
\label{ssub:sharding}

Sharding in MongoDB allows for horizontal scaling of a Mongo database, where a given database or collection is shared
among different ``shards'', or multiple MongoDB instances, generally running on separate machines. Sharding is performed
on an indexed document key, dividing documents containing that key based on either range or computed hashes. Ranged-based
sharding is generally recommended where data is generally expected to be accessed in some sort of sequence, while hash-based
sharding offers a guaranteed random distribution of data across shards, and more balanced equally-sized shards.

% subsubsection sharding (end)


% subsection further_database_features (end)


% section mongo_overview (end)

\newpage

\section{Implementation} % (fold)
\label{sec:implementation}

% section implementation (end)

\newpage

\section{Evaluation and Discussion} % (fold)
\label{sec:evaluation_and_discussion}

% section evaluation_and_discussion (end)

\newpage

\section{Conclusion} % (fold)
\label{sec:conclusion}

% section conclusion (end)

\newpage                            % Make references section

\bibliographystyle{acm}
\bibliography{biblio}

\end{document}
